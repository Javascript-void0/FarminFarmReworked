options:
	shaft: &8[&6&lRe&e&lSHAFT&7²&8]&f
	discord: &8[&e&lDISCORD&8]&f
	broadcast: &8[&e&lBROADCAST&8]&f
	rule: &8[&e&lRULE&8]&f
	permission: &7Insufficient Permissions
	gold: &7Insufficient &eGold
	gems: &7Insufficient &bGems
	medals: &7Insufficient &cMedals
	tokens: &7Insufficient &dTokens
	staff: &8[&e&lSTAFF&8]&f
	admin: &8[&6&lADMIN&8]&f
	world: world

on hunger meter change:
	cancel event
on portal create: 
	if group of player is not "admin":
		cancel event
on drop:
    if group of player is not "admin":
        cancel event
on place:
	if group of player is not "admin":
		cancel event
on pickup:
	cancel event
on item damage: 
	if durability of event-item is greater than 2029:
		broadcast "%durability of player's tool%"
		cancel event
	else if item is axe:
		stop
	else if item is pickaxe:
		stop
	else if item is shovel:
		stop
	cancel event
on shoot:
	set {_p} to held item of shooter
	if {_p} is trident:
		set slot 5 of shooter to {_p}
	if projectile is set:
		set slot 25 of shooter to 64 of arrow named "&e&lARROW &7Shop" with lore "&7> Click to Open"

on connect:
	broadcast "&8[&a+&8] &7%player%"
on disconnect:
	broadcast "&8[&c-&8] &7%player%"
on first join:
	broadcast "&8[&a+&8] &e%player% &8[&f##%size of all offline players%&8]"

command /spawn:
	trigger:
		teleport player to {spawn}

command /setspawn:
	trigger:
		if player is op:
			set {spawn} to player's position
			send "{@admin} Spawn Set to %player's position%"
		else:
			send "{@admin} {@permission}"

every 10 minutes in "{@world}":
	loop all players:
		message "{@discord} &7Join our &eDiscord &7for events, updates, and extra features (offline bonuses) <tooltip:&6Click to join!><link:https://discord.gg/y333BGhxFP>&8[&6&lCLICK HERE&8]<reset>" to loop-player

command /tps:
	trigger:
		set {_tps} to tps from the last 1 minute
		set {_t} to roundto({_tps}, 2)
		if {_t} >= 19:
			send "{@shaft} &a%{_t}% &7TPS"
		else if {_t} >= 16:
			send "{@shaft} &e%{_t}% &7TPS"
		else:
			send "{@shaft} &c%{_t}% &7TPS"

command /bc [<text>]:
	aliases: /broadcast
	trigger:
		if player is op:
			if arg-1 is set:
				broadcast colored "{@broadcast} &6%arg-1%"
			else:
				send "{@admin} /bc <msg>"
		else:
			send "{@admin} {@permission}"

command /rules: 
	trigger:
		send "{@rule} &e1. &fNo NSFW. Limit swearing."
		send "{@rule} &e2. &fEnglish only"
		send "{@rule} &e3. &fDon't spam/flood. Limit caps. "
		send "{@rule} &e4. &fRespect everyone"
		send "{@rule} &e5. &fNo advertising"
		send "{@rule} &e6. &fDon't start drama"
		send "{@rule} &e7. &fNo bugs, exploits, hacks, macros, or any unfair advantages"
		send "{@rule} &e8. &fDon't be rude, racist, or bully others"

command /pl:
	aliases: /plugins
	trigger:
		if group of player is "admin":
			execute console command "/sudo %player% bukkit:plugins"
		else:
			send "&fPlugins (4): &aNone&f, &aOf&f, &aYour&f, &aBusiness"

command /pvp:
	trigger:
		if {pvp::%player%} is not set:
			set {pvp::%player%} to false
			send "{@shaft} &7PvP &c&lDISABLED"
		else:
			delete {pvp::%player%}
			send "{@shaft} &7PvP &a&lENABLED."

on death of player:
	if attacker is not a player:
		victim is player
		if projectile is set:
			set the death message to "&8[&f☠&8] &7%player's display name% &7was shot by %attacker's display name%"
		else:
			set the death message to "&8[&f☠&8] &7%player's display name% &7was killed by %attacker's display name%"
		add 1 to {p_mdeath::%victim%}
	else if attacker is a player:
		victim is player
		add 1 to {p_pkill::%attacker%}
		add 1 to {p_pdeath::%victim%}
		if projectile is set:
			set {_msg} to new text component of "&8[&f☠&8] &7%player's display name% &7was shot by %attacker's display name% using "
		else:
			set {_msg} to new text component of "&8[&f☠&8] &7%player's display name% &7was killed by %attacker's display name% using "
		set {_weapon} to new text component of "&8[&f%name of tool of attacker%&8]"
		set {_info} to tool of attacker
		set hover event of {_weapon} to a new hover event showing {_info}
		set the death message to ""
		loop all players:
			send components {_msg} and {_weapon} to loop-player

on death of zombie:
	if attacker is a player:
		add 1 to {p_mkill::%attacker%}
on death of skeleton:
	if attacker is a player:
		add 1 to {p_mkill::%attacker%}

on damage:
	if victim is not a player:
		stop
	if attacker is not a player:
		stop
	else if attacker is a player:
		if victim is set:
			if victim is a player:
				if {pvp::%victim%} is set:
					cancel event
					set action bar of attacker to "{@shaft} &7PvP is &c&lDISABLED &7 for %victim%"
	else if attacker is set:
		if attacker is a player:
			if victim is a player:
				if {pvp::%attacker%} is set:
					cancel event
					set action bar of attacker to "{@shaft} &7Your PvP is &c&lDISABLED"

on join:
	set {_bossbar} to 0
	create bossbar titled " " and id "bossbar.%player%" for player with progress 100 with colors yellow
	while player is online:
		if {_bossbar} is 0:
			set bossbar "bossbar.%player%" value to 100
			set bossbar "bossbar.%player%" color to yellow
			set bossbar "bossbar.%player%" title to "&7Welcome to &6&lRe&e&lSHAFT&7²"
		else if {_bossbar} is 1:
			set bossbar "bossbar.%player%" value to 66
			set bossbar "bossbar.%player%" color to yellow
			set bossbar "bossbar.%player%" title to "&7IP: &6reshaft.minehut.gg"
		else if {_bossbar} is 2:
			set bossbar "bossbar.%player%" value to 33
			set bossbar "bossbar.%player%" color to yellow
			set bossbar "bossbar.%player%" title to "&7Join Our &eDiscord &7with &e/discord"
		else if {_bossbar} is 3:
			set {_format} to timeFormat({servertime})
			set bossbar "bossbar.%player%" value to 0
			set bossbar "bossbar.%player%" color to yellow
			set bossbar "bossbar.%player%" title to "&6Server Time: &e%{_format}% &7(&e%{servertime}%&et&7)"
		# else if {_bossbar} is 4:
		# 	set bossbar "bossbar.%player%" value to 20
		# 	set bossbar "bossbar.%player%" color to red
		# 	set bossbar "bossbar.%player%" title to "&eRebirth &7to collect &ebonuses &7and &egear"
		# else if {_bossbar} is 5:
		# 	set bossbar "bossbar.%player%" value to 0
		# 	set bossbar "bossbar.%player%" color to red
		# 	set bossbar "bossbar.%player%" title to "&7Help us &cdestroy &7this world"
		wait 3 seconds
		add 1 to {_bossbar}
		if {_bossbar} is 4:
			set {_bossbar} to 0
	remove bossbar "bossbar.%player%"

# ==== SERVER TIME ====

function timeFormat(t: integer) :: text: 
	set {_h} to floor({_t} / 60)
	set {_m} to {_t} - ({_h} * 60)
	if {_h} is less than 10:
		set {_h} to "0%{_h}%"
	if {_m} is 0:
		set {_m} to "00"
	else if {_m} is less than 10:
		set {_m} to "0%{_m}%"
	set {_time} to "%{_h}%:%{_m}%"
	return {_time}

command /servertime [<integer>]:
	trigger:
		if player is op:
			if arg-1 is greater than 1440:
				set {_time} to 1440
			else:
				set {_time} to arg-1
			set {servertime} to {_time}
			set {_format} to timeFormat({_time})
			send "{@admin} &7Server time set to &e%{_format}% &7(&e%{servertime}%&et&7)"
		else:
			send "{@admin} {@permission}"

every 1 minute in "{@world}":
	add 1 to {servertime}
	if {servertime} is greater than 1440:
		set {servertime} to 0
	if mod({servertime}, 60) is 0:
		set {_format} to timeFormat({servertime})
		broadcast "{@shaft} &7Server Time: &e%{_format}% &7(&e%{servertime}%t&7)"

every 1 second in "{@world}":
	loop all players:
		wipe loop-player's sidebar
		set name of sidebar of loop-player to "&6&lRe&e&lSHAFT&7²"
		set score "    " in sidebar of loop-player to 14
		set score " &e&lPLAYER &7(:L&7%{p_level::%loop-player%}%)" in sidebar of loop-player to 13
		set {_block} to format({p_block::%loop-player%})
		set score "   &7Blocks: &f%{_block}%" in sidebar of loop-player to 12
		set {_gold} to format({p_gold::%loop-player%})
		set score "   &7Gold: &f%{_gold}%" in sidebar of loop-player to 11
		set {_gem} to spaced("%{p_gem::%loop-player%}%")
		set score "   &7Gems: &f%{_gem}%" in sidebar of loop-player to 10
		set {_medal} to format({p_medal::%loop-player%})
		set score "   &7Medals: &f%{_medal}%" in sidebar of loop-player to 9
		set {_token} to spaced("%{p_token::%loop-player%}%")
		set score "   &7Tokens: &f%{_token}%" in sidebar of loop-player to 8
		set score "   &7Bonus: &f%{p_bonus::%loop-player%}%%%" in sidebar of loop-player to 7
		set score "  " in sidebar of loop-player to 6
		set score " &e&lSERVER &7(%number of all players%/10)" in sidebar of loop-player to 5
		set {_tps} to tps from the last 1 minute
		set {_t} to roundto({_tps}, 2)
		set score "   &7TPS: &f%{_t}%" in sidebar of loop-player to 4
		set {_time} to timeFormat({servertime})
		set score "   &7Time: &f%{_time}%" in sidebar of loop-player to 3
		set {_blocks} to format({serverblock})
		set score "   &7Blocks: &f%{_blocks}%" in sidebar of loop-player to 3
		set score "   &7Blessing: &f%{blessing}%%%" in sidebar of loop-player to 2
		set score " " in sidebar of loop-player to 0

# ==== World Border ====

command /serverblock [<text>] [<integer>]:
	trigger:
		if player is op:
			if arg-1 is not "add" or "remove" or "set" or "reset":
				send "{@admin} /serverblock <add remove set reset>"
			else if arg-2 is not set:
				arg-1 is not "reset"
				send "{@admin} /serverblock <%arg-1%> <integer>"
				send "{@admin} &7Added &e%arg-2% &7from server block count"
			if arg-1 is "add":
				add arg-2 to {serverblock}
			else if arg-1 is "remove":
				remove arg-2 from {serverblock}
				send "{@admin} &7Removed &e%arg-2% &7from server block count"
			else if arg-1 is "set":
				set {serverblock} to arg-2
				send "{@admin} &7Server block count set to &e%arg-2%"
			else if arg-1 is "reset":
				set {serverblock} to 0
				send "{@admin} &7Server block count set to &e0"
		else:
			send "{@admin} {@permission}"

function setWorldBorder(n: integer):
	make console execute "/minecraft:worldborder set %{_n}%"
	broadcast "{@shaft} &7Worldborder moved to &e%{_n}% &7blocks"

every 5 seconds in "{@world}":
	set {_border} to floor({serverblock} ^ (1/2))
	add 102 to {_border}
	{worldborder} is not {_border}
	set {worldborder} to {_border}
	setWorldBorder({worldborder})
		
command /worldborder [<integer>]:
	trigger:
		if player is op:
			setWorldBorder(arg-1)
			set {worldborder} to arg-1
		else:
			send "{@admin} {@permission}"

every 1 second in "world":
	loop all players:
		"%regions at loop-player%" does not contain "spawn"
		loop all blocks in radius 10 around loop-player:
			if loop-block is water or lava:
				delete loop-block		
on flow:
	if "%regions at event-block%" does not contain "spawn":
		cancel event

# ======== HEX/RGB ======== HEX/RGB ========
# ======== HEX/RGB ======== HEX/RGB ========
# ======== HEX/RGB ======== HEX/RGB ========

on load:
	set {hex::*} to split "0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|k|l|m|n|o|r" at "|"
 
function rgbToHex(values: numbers) :: string:
	loop {_values::*}:
		set {_r} to "%{_r} ? ""<##""%%{hex::%(( (round(loop-value)) - mod((round(loop-value)), 16)) / 16 + 1)%} ? """"%%{hex::%mod((round(loop-value)), 16) + 1%} ? """"%"
	return colored "%{_r}%>"

function gradient(input: string, color-from: integers, color-to: integers) :: string:
	loop {_color-from::*}:
		set {_i::%loop-index%} to ({_color-to::%loop-index%} - loop-value) / length of {_input}
	loop length of {_input} times:
		if subtext of {_input} from indices loop-number - 1 to loop-number - 1 = "§":
			set {_format} to "%{_format} ? """"%&%subtext of {_input} from indices loop-number to loop-number%" if {hex::*} contains subtext of {_input} from indices loop-number to loop-number
			clear {_format} if subtext of {_input} from indices loop-number to loop-number = "r"
			continue loop
		set {_r} to "%{_r} ? """"%%rgbToHex({_color-from::*})%%{_format} ? """"%%subtext of {_input} from indices loop-number to loop-number%"
		set {_color-from::*} to ({_color-from::1} + {_i::1}), ({_color-from::2} + {_i::2}) and ({_color-from::3} + {_i::3})
	return colored {_r}

# ======== MOB SPAWN ======== MOB SPAWN ========
# ======== MOB SPAWN ======== MOB SPAWN ========
# ======== MOB SPAWN ======== MOB SPAWN ========

on damage: 
	if victim is not a player:
		set {_name::*} to name of victim split at " "
		set {_heart} to roundto(health of victim, 1)
		set name of victim to "%{_name::1}% %{_name::2}% &7(&c%{_heart}% ❤&7)"
		set action bar of attacker to name of victim

on combust:
	if event-entity is zombie or skeleton:
		cancel event

command /setmobspawn [<text>]:
	trigger:
		if player is op:
			if arg-1 is "add":
				add player's location to {mobSpawn::*}
				send "{@admin} &7Added &e%player's location% &7 to Mob Spawn Points"
			if arg-1 is "reset":
				delete {mobSpawn::*}
				send "{@admin} &7Cleared Mob Spawn Points"
			if arg-1 is "list":
				loop {mobSpawn::*}:
					send "{@admin} &7%{mobSpawn::%loop-value%}%"
		else:
			send "{@admin} {@permission}"

on spawn of zombie:
	set {_n} to random integer between 1 and 2
	if {mobcap} is true:
		cancel event
	else if block below event-location is not grass block:
		cancel event
	else if {_n} is 1:
		set name of event-entity to "&8[&e:L100&8] &fOrc:Captain &7(&c1024 ❤&7)"
		orcCaptain(event-entity)
	else if {_n} is 2:
		set name of event-entity to "&8[&e:L100&8] &fOrc:Warrior &7(&c1024 ❤&7)"
		orcWarrior(event-entity)
on spawn of skeleton:
	set {_n} to random integer between 1 and 2
	if {mobcap} is true:
		cancel event
	else if block below event-location is not grass block:
		cancel event
	else if {_n} is 1:
		set name of event-entity to "&8[&e:L100&8] &fBone:Warrior &7(&c1024 ❤&7)"
		boneWarrior(event-entity)
	else if {_n} is 2:
		set name of event-entity to "&8[&e:L100&8] &fBone:Archer &7(&c1024 ❤&7)"
		boneArcher(event-entity)
on spawn of creeper:
#	if {mobcap} is false:
	cancel event
on spawn of enderman:
#	if {mobcap} is false:
	cancel event
on spawn of witch:
#	if {mobcap} is false:
	cancel event
on spawn of spider:
#	if {mobcap} is false:
	cancel event
on spawn of chicken:
	cancel event
on spawn of pig:
#	if {mobcap} is false:
	cancel event
on spawn of cow:
#	if {mobcap} is false:
	cancel event
on spawn of sheep:
#	if {mobcap} is false:
	cancel event

every 10 seconds in "{@world}":
	loop all entities:
		loop-entity is not a player
		if "%region at loop-entity%" does not contain "spawn":
			delete loop-entity
	set {_p} to number of players
	set {_d} to number of entities in "{@world}" - {_p}
	if {_d} is greater than 50:
		set {mobcap} to true
	else:
		set {mobcap} to false

# ======== BLESSING  ======== BLESSING  ========
# ======== BLESSING  ======== BLESSING  ========
# ======== BLESSING  ======== BLESSING ========

command /blessing [<integer>]:
	trigger:
		if player is op:
			if arg-1 is set:
				set {blessing} to arg-1
				send "{@admin} Set Global Blessing to %arg-1%%%"
			else:
				send "{@admin} /blessing <integer>"
		else:
			send "{@admin} {@permission}"

# ======== PLAYER STATS ======== PLAYER STATS ========
# ======== PLAYER STATS ======== PLAYER STATS ========
# ======== PLAYER STATS ======== PLAYER STATS ========

on join:
	if {p_level::%player%} is not set:
		set {p_level::%player%} to 1
	if {p_gold::%player%} is not set:
		set {p_gold::%player%} to 0
	if {p_gem::%player%} is not set:
		set {p_gem::%player%} to 0
	if {p_medal::%player%} is not set:
		set {p_medal::%player%} to 0
	if {p_token::%player%} is not set:
		set {p_token::%player%} to 0
	if {p_bonus::%player%} is not set:
		set {p_bonus::%player%} to 100
	if {p_block::%player%} is not set:
		set {p_block::%player%} to 0
	if {p_totalblock::%player%} is not set:
		set {p_totalblock::%player%} to 0
	if {p_totalgold::%player%} is not set:
		set {p_totalgold::%player%} to 0
	if {p_totalmedal::%player%} is not set:
		set {p_totalmedal::%player%} to 0
	if {p_mkill::%player%} is not set:
		set {p_mkill::%player%} to 0
	if {p_mdeath::%player%} is not set:
		set {p_mdeath::%player%} to 0
	if {p_pkill::%player%} is not set:
		set {p_pkill::%player%} to 0
	if {p_pdeath::%player%} is not set:
		set {p_pdeath::%player%} to 0
	if {p_rebirth::%player%} is not set:
		set {p_rebirth::%player%} to 0

# ======== /TOP ======== /TOP ========
# ======== /TOP ======== /TOP ========
# ======== /TOP ======== /TOP ========

command /top [<text>]:
	trigger:
		if arg-1 is not "level" or "gold" or "totalgold" or "gem" or "medal" or "token" or "totaltoken" or "totalblock" or "pkill" or "mkill" or "rebirth":
			send "{@shaft} /top <level gold total gold gem medal token totaltoken totalblock pkill mkill rebirth>"
		else:
			loop {%arg-1%::*}:
				add 1 to {_size}
				if {_low.to.high.list::%loop-value%} is not set:
					set {_low.to.high.list::%loop-value%} to loop-index
				else:
					set {_n} to 0
					loop {_size} times:
						set {_n} to {_n}+1
						{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
						set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
						stop loop
			wait 1 tick
			set {_n} to size of {_low.to.high.list::*}
			loop {_low.to.high.list::*}:
				set {_high.to.low.list::%{_n}%} to loop-value
				set {_n} to {_n}-1
			wait 1 tick
			set {_i} to 0
			send "&7&m-----------&r &8[ &e&lTOP &8] &7&m-------------"
			loop {_high.to.low.list::*}:
				if arg-1 is "level":
					set {_label} to "&e:L%{p_%arg-1%::%loop-value%}%"
				else if arg-1 is "gold" or "totalgold":
					set {_gold} to format({p_%arg-1%::%loop-value%})
					set {_label} to "&e%{_gold}% &7gold"
				else if arg-1 is "gem":
					set {_gem} to spaced("%{p_%arg-1%::%loop-value%}%")
					set {_label} to "&e%{_gem}% &7gems"
				else if arg-1 is "medal" or "totalmedal":
					set {_medal} to format({p_%arg-1%::%loop-value%})
					set {_label} to "&e%{_medal}% &7medals"
				else if arg-1 is "token":
					set {_token} to spaced("%{p_%arg-1%::%loop-value%}%")
					set {_label} to "&e%{_token}% &7tokens"
				else if arg-1 is "totalblock":
					set {_block} to format({p_%arg-1%::%loop-value%})
					set {_label} to "&e%{_block}% &7blocks"
				else if arg-1 is "mkill" or "pkill":
					set {_label} to "&e%{p_%arg-1%::%loop-value%}% &7kills"
				else if arg-1 is "rebirth":
					set {_label} to "&e%{p_%arg-1%::%loop-value%}% &7times"
				add 1 to {_topnumber}
				set {_player} to "%loop-value%" parsed as offline player
				send "&7%{_topnumber}%&7. %{_player}%: %{_label}%"
				add 1 to {_i}
				if {_topnumber} > 10:
					stop
			send "&7&m--------------------------------"

# ======== CHAT FORMAT ======== CHAT FORMAT ========
# ======== CHAT FORMAT ======== CHAT FORMAT ========
# ======== CHAT FORMAT ======== CHAT FORMAT ========

on chat:
	set {_player} to display name of player
	if group of player is "admin":
		set {_prefix} to "&6&lADMIN&8]&r &8[&e:L"
	else if group of player is "mod":
		set {_prefix} to "&e&lMOD&8]&r &8[&e:L"
	else:
		set {_prefix} to "&7:L"

	if group of player is "admin" or "mod":
		set {_level} to a new text component of "&e%{p_level::%player%}%"
	else:
		set {_level} to a new text component of "&7%{p_level::%player%}%"
	set {_gold} to format({p_gold::%player%})
	set {_gem} to spaced("%{p_gem::%player%}%")
	set {_medal} to format({p_medal::%player%})
	set {_token} to spaced("%{p_token::%player%}%")
	set {_total} to format({p_totalblock::%player%})
	set {_stats} to bedrock named "&8[&e:L%{p_level::%player%}%&8] &f%{_player}%" with lore "&eGold: &7%{_gold}%" and "&bGems: &7%{_gem}%" and "&cMedals: &7%{_medal}%" and "&dTokens: &7%{_token}%" and "&7Blocks: &7%{_total}%" and "&7Bonus: &7%{p_bonus::%player%}%%%"
	set hover event of {_level} to a new hover event showing {_stats}

	set {_slotList::hand} to index of player's hotbar slot
	set {_keywordList::hand::*} to "[hand]", "[item]" and "[i]"
	set {_slotList::offhand} to 40
	set {_keywordList::offhand::*} to "[offhand]"
	set {_slotList::helmet} to 39
	set {_keywordList::helmet::*} to "[helmet]", "[helm]", "[cap]" and "[head]"
	set {_slotList::chestplate} to 38
	set {_keywordList::chestplate::*} to "[chestplate]", "[tunic]" and "[chest]"
	set {_slotList::leggings} to 37
	set {_keywordList::leggings::*} to "[leggings]", "[pants]" and "[legs]"
	set {_slotList::boots} to 36
	set {_keywordList::boots::*} to "[boots]" and "[feet]"
	loop indices of {_keywordList::*}:
		loop {_keywordList::%loop-value%::*}:
			message contains loop-value-2
			add {_slotList::%loop-value-1%} to {_items::*}
			add loop-value-2 to {_keywords::*}
			exit 1 loop
	if size of {_keywords::*} > 0:
		cancel event
		set {_message} to message
		loop {_keywords::*}:
			loop indices of {_keywordList::*}:
				{_keywordList::%loop-value-2%::*} contains loop-value-1
				loop {_keywordList::%loop-value-2%::*}:
					loop-value-3 is not loop-value-1
					replace all loop-value-3 with "" in {_message}
			set {_messages::*} to {_message} split at "%loop-value%"
			set {_temp} to {_messages::1}
			delete {_messages::1}
			set {_message} to "&7%{_temp}%%loop-value%&7%join {_messages::*} with """"%"
			replace all loop-value with "{CIplaceholder}:{%loop-index%}:{CIplaceholder}" in {_message}
		set {_messages::*} to {_message} split at "{CIplaceholder}"
		loop {_messages::*}:
			set {_messages::%loop-index%} to a new text component of "%loop-value%"
			"%loop-value%" is ":{1}:", ":{2}:", ":{3}:", ":{4}:", ":{5}:" or ":{6}:"
			set {_itemIndex} to subtext of "%loop-value%" from characters 3 to 3
			set {_itemIndexes::%{_itemIndex}%} to loop-index
		loop {_items::*}:
			delete {_name}
			set {_item} to loop-value
			if {_item} is a number:
				set {_item} to slot {_item} of player's inventory
			if {_item} is not set:
				set {_messages::%{_itemIndexes::%loop-index%}%} to a new text component of "&7%{_keywords::%loop-index%}%"
			else if {_item} is not air:
				set {_name} to name of {_item}
				if {_name} is not set:
					set {_name} to a new translate component from {_item}
				set {_itemName} to a new text component of "&8[&r%{_name}%&8]&r"
				set hover event of {_itemName} to a new hover event showing {_item}
				set {_messages::%{_itemIndexes::%loop-index%}%} to {_itemName}
			else:
				set {_messages::%{_itemIndexes::%loop-index%}%} to a new text component of "&7%{_keywords::%loop-index%}%"
		set {_messageFormat::*} to message format split at "[message]"
		replace "<[player]>" with "%{_player}%&7:&r" in {_messageFormat::1}
		replace "world" with "" in {_messageFormat::*}
		replace "[" with "" in {_messageFormat::*}
		replace "]" with "" in {_messageFormat::*}
		if message format contains message:
			set {_messageFormat::*} to message format split at message
		set {_temp} to a new text component of "%{_messageFormat::1}%"
		set {_p} to a new text component of "&8[%{_prefix}%"
		set {_s} to a new text component of "&8] "
		set {_} to a new text component of "&7: "
		delete {_messageFormat::1}
		loop all players:
			send components {_p}, {_level}, {_s}, {_temp}, {_messages::*} and {_messageFormat::*} to loop-player
		send components {_p}, {_level}, {_s}, {_temp}, {_messages::*} and {_messageFormat::*} to console
		if group of player is "admin":
			send "[Admin] [:L%{p_level::%player%}%] %uncolored display name of player%: %message%" to channel with id "872657350316687362" with "ReShaft"
		else if group of player is "mod":
			send "[Mod] [:L%{p_level::%player%}%] %uncolored display name of player%: %message%" to channel with id "872657350316687362" with "ReShaft"
		else:
			send "[:L%{p_level::%player%}%] %uncolored display name of player%: %message%" to channel with id "872657350316687362" with "ReShaft"
	else:
		cancel event
		set {_message} to a new text component of "&7%message%"
		set {_player} to a new text component of {_player}
		set {_p} to a new text component of "&8[%{_prefix}%"
		set {_s} to a new text component of "&8] &f"
		set {_} to a new text component of "&7: "
		loop all players:
			send components {_p}, {_level}, {_s}, {_player}, {_}, and {_message} to loop-player
		send components {_p}, {_level}, {_s}, {_player}, {_}, and {_message} to console
		if group of player is "admin":
			send "[Admin] [:L%{p_level::%player%}%] %uncolored display name of player%: %message%" to channel with id "872657350316687362" with "ReShaft"
		else if group of player is "mod":
			send "[Mod] [:L%{p_level::%player%}%] %uncolored display name of player%: %message%" to channel with id "872657350316687362" with "ReShaft"
		else:
			send "[:L%{p_level::%player%}%] %uncolored display name of player%: %message%" to channel with id "872657350316687362" with "ReShaft"

# ======== NUMBER FORMAT ======== NUMBER FORMAT ========
# ======== NUMBER FORMAT ======== NUMBER FORMAT ========
# ======== NUMBER FORMAT ======== NUMBER FORMAT ========

function roundto(n: number, to: number) :: number:
   return floor(({_n} * 10^{_to}) + 0.5) / 10^{_to}

function format(n: number) :: text:
	set {_data} to "f,18|e,15|d,12|c,9|b,6|a,3"
	loop split {_data} at "|":
		set {_s::*} to split loop-value at ","
		{_n} >= 10 ^ {_s::2} parsed as number
		set {_nn} to roundto({_n} / 10 ^ {_s::2} parsed as number, 1)
		return "%{_nn}%%{_s::1}%"
	return "%{_n}%"

function spaced(n: text) :: text:
	set {_s::*} to split {_n} at "."
	if {_s::2} is not set:
		return a({_n})
	else:
		return "%a({_s::1})%.%{_s::2}%"
 
function a(b: text) :: text:
	if length of {_b} > 3:
		return "%a(first length of {_b} - 3 characters of {_b})%,%last 3 characters of {_b}%"
	return {_b}

# ======== PLAYER INVENTORY ======== PLAYER INVENTORY ========
# ======== PLAYER INVENTORY ======== PLAYER INVENTORY ========
# ======== PLAYER INVENTORY ======== PLAYER INVENTORY ========

command /new [<text>]:
	trigger:
		if player is op:
			if arg-1 is "lock" or "locked":
				newlock(player)
			else if arg-1 is "unlock" or "unlocked":
				new(player)

function new(p: player):
	set helmet of {_p} to {1_helmet}
	set chestplate of {_p} to {1_chestplate}
	set leggings of {_p} to {1_leggings}
	set boots of {_p} to {1_boots}
	set slot 0 of {_p} to {1_pickaxe}
	set slot 1 of {_p} to {1_axe}
	set slot 2 of {_p} to {1_shovel}
	set slot 3 of {_p} to {1_bow}
	set slot 4 of {_p} to {1_crossbow}
	set slot 5 of {_p} to {1_trident}
	set slot 12 of {_p} to {talaria}
	set slot 13 of {_p} to {zeus}
	set slot 14 of {_p} to {hermes}
	set slot 21 of {_p} to {apollo}
	set slot 22 of {_p} to {hades}
	set slot 23 of {_p} to {kronos}
	set slot 30 of {_p} to {pegasus}
	set slot 31 of {_p} to {athena}
	set slot 32 of {_p} to {poseidon}
	set slot 9, 10, 11, 15, 16, 17, 18, 19, 20, 24, 26, 27, 28, 29, 33, 34, and 35 of {_p} to gray stained glass pane named " "
	set slot 6 of {_p} to smithing table named "&e&lARMOR" with lore "&7Right Click To Upgrade &eArmor &7With &dTokens" and "&7 > &eArmor &7upgrades are permanent"
	set slot 7 of {_p} to anvil named "&e&lSETTINGS" with lore "&7Right Click To Disable or Enable Options"
	set slot 8 of {_p} to skull of {_p} named "&e&lSTATISTICS" with lore "&7Right Click To View Your Stats"
	set slot 25 of {_p} to 64 of arrow named "&e&lARROW &7Shop" with lore "&7> Click to Open"

function newlock(p: player):
	set helmet of {_p} to {1_helmet}
	set chestplate of {_p} to {1_chestplate}
	set leggings of {_p} to {1_leggings}
	set boots of {_p} to {1_boots}
	set slot 0 of {_p} to {1_pickaxe}
	set slot 1 of {_p} to {1_axe}
	set slot 2 of {_p} to {1_shovel}
	set slot 3 of {_p} to {1_bow}
	set slot 4 of {_p} to {1_crossbow}
	set slot 5 of {_p} to {1_trident}
	set slot 12 of {_p} to {talarialock}
	set slot 13 of {_p} to {zeuslock}
	set slot 14 of {_p} to {hermeslock}
	set slot 21 of {_p} to {apollolock}
	set slot 22 of {_p} to {hadeslock}
	set slot 23 of {_p} to {kronoslock}
	set slot 30 of {_p} to {pegasuslock}
	set slot 31 of {_p} to {athenalock}
	set slot 32 of {_p} to {poseidonlock}
	set slot 9, 10, 11, 15, 16, 17, 18, 19, 20, 24, 26, 27, 28, 29, 33, 34, and 35 of {_p} to gray stained glass pane named " "
	set slot 6 of {_p} to smithing table named "&e&lARMOR" with lore "&7Right Click To Upgrade &eArmor &7With &dTokens" and "&7 > &eArmor &7upgrades are permanent"
	set slot 7 of {_p} to anvil named "&e&lSETTINGS" with lore "&7Right Click To Disable or Enable Options"
	set slot 8 of {_p} to skull of {_p} named "&e&lSTATISTICS" with lore "&7Right Click To View Your Stats"
	set slot 25 of {_p} to 64 of arrow named "&e&lARROW &7Shop" with lore "&7> Click to Open"

# ======== HOTBAR MENU ======== HOTBAR MENU ========
# ======== HOTBAR MENU ======== HOTBAR MENU ========
# ======== HOTBAR MENU ======== HOTBAR MENU ========

function hat(p: player, i: item, s: integer):
	set {_cur} to helmet of {_p}
	set helmet of {_p} to {_i}
	set slot {_s} of {_p} to {_cur}

function hatreset(p: player):
	set {_13} to slot 12 of {_p}
	if {_13} is light gray stained glass:
		set {_item} to {_13}
		set {_slot} to 12
	set {_21} to slot 21 of {_p}
	if {_21} is light gray stained glass:
		set {_item} to {_21}
		set {_slot} to 21
	set {_23} to slot 23 of {_p}
	if {_23} is light gray stained glass:
		set {_item} to {_23}
		set {_slot} to 23
	set {_14} to slot 22 of {_p}
	if {_14} is light gray stained glass:
		set {_item} to {_14}
		set {_slot} to 22
	set {_30} to slot 30 of {_p}
	if {_30} is light gray stained glass:
		set {_item} to {_30}
		set {_slot} to 30
	set {_31} to slot 31 of {_p}
	if {_31} is light gray stained glass:
		set {_item} to {_31}
		set {_slot} to 31
	set {_32} to slot 32 of {_p}
	if {_32} is light gray stained glass:
		set {_item} to {_32}
		set {_slot} to 32
	set {_cur} to helmet of {_p}
	if {_cur} is not light gray stained glass:
		hat({_p}, {_item}, {_slot})
	remove absorption from {_p}
	remove resistance from {_p}
	set flight mode of {_p} to false

function unlock(p: player, c: integer, s: integer):
	if {p_gem::%{_p}%} is greater than {_c}:
		remove {_c} from {p_gem::%{_p}%}
		if {_s} is 12:
			set slot 12 of {_p} to {talaria}
			send "{@shaft} &7Unlocked &bTalaria" to {_p}
		if {_s} is 13:
			set slot 13 of {_p} to {zeus}
			send "{@shaft} &7Unlocked &bZeus" to {_p}
		if {_s} is 14:
			set slot 14 of {_p} to {hermes}
			send "{@shaft} &7Unlocked &bHermes" to {_p}
		if {_s} is 21:
			set slot 21 of {_p} to {apollo}
			send "{@shaft} &7Unlocked &bApollo" to {_p}
		if {_s} is 22:
			set slot 22 of {_p} to {hades}
			send "{@shaft} &7Unlocked &bHades" to {_p}
		if {_s} is 23:
			set slot 23 of {_p} to {kronos}
			send "{@shaft} &7Unlocked &bKronos" to {_p}
		if {_s} is 30:
			set slot 30 of {_p} to {pegasus}
			send "{@shaft} &7Unlocked &bPegasus" to {_p}
		if {_s} is 31:
			set slot 31 of {_p} to {athena}
			send "{@shaft} &7Unlocked &bAthena" to {_p}
		if {_s} is 32:
			set slot 32 of {_p} to {poseidon}
			send "{@shaft} &7Unlocked &bPoseidon" to {_p}
	else:
		send "{@shaft} {@gems}" to {_p}

function arrowShop(p: player):
	open virtual chest inventory with size 1 named "&e&lARROW &8Shop" to {_p}
	format gui slot 0 of {_p} with arrow

on inventory click:
	if name of event-inventory is not "Crafting":
		cancel event
		stop
	# if clicked slot is 0:
	# 	gamemode of player is survival
	# 	set {_i} to slot 0 of player
	# 	set slot 40 of player to {_i}
	# if clicked slot is 1:
	# 	gamemode of player is survival
	# 	set {_i} to slot 1 of player
	# 	set slot 40 of player to {_i}
	# if clicked slot is 2:
	# 	gamemode of player is survival
	# 	set {_i} to slot 2 of player
	# 	set slot 40 of player to {_i}
	if clicked slot is 25:
		gamemode of player is survival
		close player's inventory
		arrowShop(player)
	if clicked slot is 36:
		gamemode of player is survival
		close player's inventory
		armor(player)
	if clicked slot is 37:
		gamemode of player is survival
		close player's inventory
		armor(player)
	if clicked slot is 38:
		gamemode of player is survival
		close player's inventory
		armor(player)
	if clicked slot is 39:
		gamemode of player is survival
		close player's inventory
		armor(player)
	if clicked slot is 40:
		gamemode of player is survival
		delete slot 40 of player
	if clicked slot is 12:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 10000, 12)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
			set player's flight mode to true
		else:
			set player's flight mode to false
		hat(player, event-item, 12)
	else if clicked slot is 13:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 13)
			stop
		set {_cur} to chestplate of player
		set {_new} to event-item
		set chestplate of player to {_new}
		set slot 13 of player to {_cur}
	else if clicked slot is 14:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 10000, 14)
			stop
		set {_cur} to boots of player
		set {_new} to event-item
		set boots of player to {_new}
		set slot 14 of player to {_cur}
	else if clicked slot is 21:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 21)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
			apply absorption 5 to player for 9999 days
		else:
			remove absorption from player
		hat(player, event-item, 21)
	else if clicked slot is 22:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 22)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
		hat(player, event-item, 22)
	else if clicked slot is 23:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 23)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
			apply resistance 2 to player for 9999 days
		else:
			remove resistance from player
		hat(player, event-item, 23)
	else if clicked slot is 30:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 30)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
		hat(player, event-item, 30)
	else if clicked slot is 31:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 31)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
		hat(player, event-item, 31)
	else if clicked slot is 32:
		cancel event
		if name of event-item contains "&c&lLOCKED":
			unlock(player, 5000, 32)
			stop
		if event-item is not light gray stained glass:
			hatreset(player)
		hat(player, event-item, 32)
	if group of player is not "admin":
		cancel event

# ======== HOTBAR FUNCTIONS ======== HOTBAR FUNCTIONS ========
# ======== HOTBAR FUNCTIONS ======== HOTBAR FUNCTIONS ========
# ======== HOTBAR FUNCTIONS ======== HOTBAR FUNCTIONS ========

function settings(p: player):
	open virtual chest inventory with size 1 named "&e&lSETTINGS &8Menu" to {_p}
	if {pvp::%{_p}%} is false:
		format gui slot 0 of {_p} with red dye named "&7&lPvP &c&lDISABLED" with lore "&7 > Click to Enable (/pvp)" to run:
			delete {pvp::%{_p}%}
			settings({_p})
	else:
		format gui slot 0 of {_p} with lime dye named "&7&lPvP &a&lENABLED" with lore "&7 > Click to Disable (/pvp)" to run:
			set {pvp::%{_p}%} to false
			settings({_p})
	format gui slot 1 of {_p} with nether star named "&e&lSPAWN" with lore "&7 > Click to teleport" to run:
		teleport {_p} to {spawn}
	set {_waited} to difference between {daily.%{_p}%.lastused} and now
	set {_next} to 1 day after {daily.%{_p}%.lastused}
	if {_waited} is less than 24 hours:
		format gui slot 8 of {_p} with minecart named "&7&lDAILY &e&lREWARD" with lore "&7Next Avaiable: %{_next}%" and "&7> &7Already &cClaimed " and "&7> &b+100 &7Gems" to run:
			send "{@shaft} &7Your daily reward was already claimed at &e%{daily.%{_p}%.lastused}%" to {_p}
			settings({_p})
	else:
		if {_waited} is not set:
			set {_m} to "Never Used"
		else:
			set {_m} to "%{daily.%{_p}%.lastused}%"
		format gui slot 8 of {_p} with minecart with chest named "&7&lDAILY &e&lREWARD" with lore "&7Last Used: %{_m}%" and "&7> &7Ready to &aClaim" and "&7> &b+100 &7Gems" to run:
			set {daily.%{_p}%.lastused} to now
			send "{@shaft} &7You claimed your daily reward at &e%now%" to {_p}
			add 100 to {gem.%{_p}%}
			settings({_p})
	set {daily.%{_p}%.lastused} to 1 day before {daily.%{_p}%.lastused}

command /dailyreset [<offline player>]:
	trigger:
		if command executor is op:
			clear {daily.%arg-1%.lastused}
			send "{@admin} &7Reset daily reward of &e%arg-1%"
			send "{@shaft} &7Your daily reward has neen reset" to arg-1
		else:
			send "{@admin} {@permission}"

command /stats [<offline player>]:
	trigger:
		if arg-1 is not set:
			stats(player)
		else:
			stats(arg-1)

function stats(p: player):
	open virtual chest inventory with size 3 named "&e&lSTATS: &8%{_p}%" to {_p}
	format gui slot 2 of {_p} with compass named "&6Position: &f%location of {_p}%" with lore "&7 > For those without F3...?"
	format gui slot 4 of {_p} with head of {_p} named "&7:L%{p_level::%{_p}%}%&8: &e%display name of {_p}%"
	format gui slot 6 of {_p} with clock named "&6Playtime: &f%time played of {_p}%" with lore "&7 > Total time spent online"
	set {_gold} to format({p_gold::%{_p}%})
	set {_totalgold} to format({p_totalgold::%{_p}%})
	format gui slot 10 of {_p} with gold ingot named "&6&lGOLD" with lore "&7Current: &6%{_gold}% &7gold" and "&7Total: &6%{_totalgold}% &7gold"
	set {_token} to spaced("%{p_token::%{_p}%}%")
	format gui slot 11 of {_p} with sunflower named "&d&lTOKENS" with lore "&7Total: &d%{_token}% &7tokens"
	set {_medal} to format({p_medal::%{_p}%})
	set {_totalmedal} to format({p_totalmedal::%{_p}%})
	format gui slot 12 of {_p} with bell named "&c&lMEDALS" with lore "&7Current: &c%{_medal}% &7medals" and "&7Total: &c%{_totalmedal}% &7medals"
	set {_gem} to spaced("%{p_gem::%{_p}%}%")
	format gui slot 13 of {_p} with emerald named "&b&lGEMS" with lore "&7Total: &b%{_gem}% &7gems"
	set {_total} to format({p_totalblock::%{_p}%})
	set {_block} to format({p_block::%{_p}%})
	format gui slot 14 of {_p} with grass block named "&a&lBLOCKS" with lore "&7Since Last Rebirth: &a%{_block}% &7blocks" and "&7Total: &a%{_total}% &7blocks"
	format gui slot 15 of {_p} with cookie named "&b&lBONUS" with lore "&7Current: &b%{p_bonus::%{_p}%}%%%" and "&7 > Depends on your current gear"
	format gui slot 16 of {_p} with nether star named "&b&lREBIRTH" with lore "&7Total: &b%{p_rebirth::%{_p}%}% &7times"
	format gui slot 19 of {_p} with zombie skull named "&c&lPvE" with lore "&7Kills: &c%{p_mkill::%{_p}%}% &7mobs killed" and "&7Deaths: &c%{p_mdeath::%{_p}%}% &7deaths"
	format gui slot 20 of {_p} with skeleton skull named "&c&lPvP" with lore "&7Kills: &c%{p_pkill::%{_p}%}% &7players killed" and "&7Deaths: &c%{p_pdeath::%{_p}%}% &7deaths"

function removeLoreLabel(t: text) :: number:
	set {_n} to uncolored {_t}
	replace "Medals: [+" with "" in {_n}
	replace "]" with "" in {_n}
	replace "%% Bonus" with "" in {_n}
	set {_r} to {_n} parsed as number
	return {_r}

function medalUpgrade(p: player, c: number):
	set {_1} to removeLoreLabel(line 1 of lore of tool of {_p})
	if {p_medal::%{_p}%} is greater than {_c}:
		remove {_c} from {p_medal::%{_p}%}
		add 1 to {_1}
		set line 1 of lore of tool of {_p} to "&eMedals: &8[&e+%{_1}%&8]"
		tool({_p})
	else:
		send "{@shaft} {@medals}" to {_p}

function bonusUpgrade(p: player, c: number):
	set {_2} to removeLoreLabel(line 2 of lore of tool of {_p})
	if {p_gold::%{_p}%} is greater than {_c}:
		remove {_c} from {p_gold::%{_p}%}
		set {_n2} to {_2} * 2
		set line 2 of lore of tool of {_p} to "&b%{_n2}%%% &7Bonus"
		tool({_p})
	else:
		send "{@shaft} {@gold}" to {_p}

function rebirth(p: player):
	if {p_block::%{_p}%} is less than 2000:
		set {_m} to 2000 - {p_block::%{_p}%}
		send "{@shaft} &7You need to mine &c%{_m}% &7more blocks before rebirth" to {_p}
	else:
		set {_level} to floor({p_block::%{_p}%} / 1000)
		set {_before} to {p_level::%{_p}%}
		if {_before} is less than {_level}:
			set {p_level::%{_p}%} to {_level}
			set {_dif} to {_level} - {_before}
			send "{@shaft} &7Player Level increased from &e%{_before}% &7to &e%{_level}% &7(&e+%{_dif}%&7)" to {_p}
		rebirthnew({_p})
		set {_blessing} to {blessing} / 100
		set {_medals} to {p_block::%{_p}%} * {_blessing}
		add {_medals} to {p_medal::%{_p}%}
		add {_medals} to {p_totalmedal::%{_p}%}
		set {p_block::%{_p}%} to 0
		set {p_gold::%{_p}%} to 0
		set {_m} to format({_medals})
		add 1 to {p_rebirth::%{_p}%}
		send "{@shaft} &7You rebirthed and gained &e%{_m}% &7medals" to {_p}

function rebirthnew(p: player):
	set {_item} to slot 0 of {_p}
	set {_bind} to level of curse of binding on {_item}
	if {_bind} is not set:
		disenchant {_item}
	repair {_item}
	set line 2 of lore of {_item} to "&b0.3125%% &7Bonus"
	set slot 0 of {_p} to {_item}

	set {_item} to slot 1 of {_p}
	set {_bind} to level of curse of binding on {_item}
	if {_bind} is not set:
		disenchant {_item}
	repair {_item}
	set line 2 of lore of {_item} to "&b0.3125%% &7Bonus"
	set slot 1 of {_p} to {_item}

	set {_item} to slot 2 of {_p}
	set {_bind} to level of curse of binding on {_item}
	if {_bind} is not set:
		disenchant {_item}
	repair {_item}
	set line 2 of lore of {_item} to "&b0.3125%% &7Bonus"
	set slot 2 of {_p} to {_item}

function enchants(p: player):
	open virtual chest inventory with size 1 named "&c&lENCHANT &8Menu" to {_p}
	format gui slot 0 of {_p} with held item of {_p}
	set {_l} to level of unbreaking of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to ({_l} + 1) * 500000
	set {_cf} to format({_c})
	if {_l} is greater or equal to {p_level::%{_p}%}:
		set {_c} to "&c&lMAX"
	format gui slot 1 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&7Unbreaking" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f%{p_level::%{_p}%}%" and "&eCost: &f%{_cf}% &eGold" to run:
		if {_l} is greater or equal to {p_level::%{_p}%}:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "unbreaking %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eUnbreaking &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gold}" to {_p}
		enchants({_p})
	delete {_l}
	set {_l} to level of efficiency of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to ({_l} + 1) * 100000
	set {_cf} to format({_c})
	if {_l} is greater or equal to 15:
		set {_c} to "&c&lMAX"
	format gui slot 2 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&7Efficiency" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f15" and "&eCost: &f%{_cf}% &eGold" to run: 
		if {_l} is greater or equal to 15:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "efficiency %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eEfficiency &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gold}" to {_p}
		enchants({_p})
	delete {_l}
	set {_l} to level of silk touch of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to ({_l} + 1) * 50000
	set {_cf} to format({_c})
	if {_l} is greater or equal to 10:
		set {_c} to "&c&lMAX"
	format gui slot 3 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&7Silk Touch" and "&7&o<none>" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f10" and "&eCost: &f%{_cf}% &eGold" to run:
		if {_l} is greater or equal to 10:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "silk touch %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eSilk Touch &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gold}" to {_p}
		enchants({_p})
	delete {_l}
	set {_l} to level of fortune of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to ({_l} + 1) * 50000
	set {_cf} to format({_c})
	if {_l} is greater or equal to 10:
		set {_c} to "&c&lMAX"
	format gui slot 4 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&7Fortune" and "&7&o<none>" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f10" and "&eCost: &f%{_cf}% &eGold" to run:
		if {_l} is greater or equal to 10:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "fortune %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eFortune &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gold}" to {_p}
		enchants({_p})
	delete {_l}
	set {_l} to level of mending of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to ({_l} + 1) * 100000
	set {_cf} to format({_c})
	if {_l} is greater or equal to 5:
		set {_c} to "&c&lMAX"
	format gui slot 5 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&7Mending" and "&7&o+1 20%% Repair for every level" and  "&7&o(Activates when tool is broken)" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f5" and "&eCost: &f%{_cf}% &eGold" to run: 
		if {_l} is greater or equal to 5:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "mending %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eMending &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gold}" to {_p}
		enchants({_p})
	delete {_l}
	set {_l} to level of curse of vanishing of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to 15000
	set {_cf} to spaced("%{_c}%")
	if {_l} is greater or equal to 1:
		set {_c} to "&c&lMAX"
	format gui slot 6 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&cCurse of Vanishing" and "&7&o<none>" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f1" and "&eCost: &f%{_cf}% &bGems" to run: 
		if {_l} is greater or equal to 1:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "curse of vanishing %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eCurse of Vanishing &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gems}" to {_p}
		enchants({_p})
	delete {_l}
	set {_l} to level of curse of binding of held item of {_p}
	if {_l} is not set:
		set {_l} to 0
	set {_c} to 15000
	set {_cf} to spaced("%{_c}%")
	if {_l} is greater or equal to 1:
		set {_c} to "&c&lMAX"
	format gui slot 7 of {_p} with shiny book named "&eEnchanted Book" with lore "&9Tools" and "&cCurse of Binding" and "&7&oKeep Enchantments After &bRebirth" and "&7 > Current: &f%{_l}%" and "&7 > Max: &f1" and "&eCost: &f%{_cf}% &bGems" to run: 
		if {_l} is greater or equal to 1:
			send "{@shaft} &cMax Level" to {_p}
			stop
		if {p_gold::%{_p}%} is greater than {_c}:
			set {_new} to {_l} + 1
			enchant held item of {_p} with "curse of binding %{_new}%" parsed as enchantment type
			remove {_c} from {p_gold::%{_p}%}
			send "{@shaft} &7Upgraded &eCurse of Binding &7to &e%{_new}%" to {_p}
		else:
			send "{@shaft} {@gems}" to {_p}
		enchants({_p})
	format gui slot 8 of {_p} with arrow named "&7 < &cBack" with lore "&7Click to go back" to run function tool({_p})

function bowenchant(p: player):
	open virtual chest inventory with size 1 named "&c&lENCHANT &8Menu" to {_p}
	format gui slot 0 of {_p} with held item of {_p}

function crossbowenchant(p: player):
	open virtual chest inventory with size 1 named "&c&lENCHANT &8Menu" to {_p}
	format gui slot 0 of {_p} with held item of {_p}

function trident(p: player):
	open virtual chest inventory with size 1 named "&c&lENCHANT &8Menu" to {_p}
	format gui slot 0 of {_p} with held item of {_p}

function tool(p: player):
	if tool of {_p} is pickaxe:
		open virtual chest inventory with size 1 named "&e&lPICKAXE &8Menu" to {_p}
	else if tool of {_p} is axe:
		open virtual chest inventory with size 1 named "&e&lAXE &8Menu" to {_p}
	else if tool of {_p} is shovel:
		open virtual chest inventory with size 1 named "&e&lSHOVEL &8Menu" to {_p}
	else if tool of {_p} is bow:
		open virtual chest inventory with size 1 named "&e&lSOl&6&lAR &8Menu" to {_p}
	else if tool of {_p} is crossbow:
		open virtual chest inventory with size 1 named "&a&lTERRE&2&lSTRIAl &8Menu" to {_p}	
	else if tool of {_p} is trident:
		open virtual chest inventory with size 1 named "&b&llUN&3&lAR &8Menu" to {_p}	
	set {_1} to removeLoreLabel(line 1 of lore of tool of {_p})
	set {_2} to removeLoreLabel(line 2 of lore of tool of {_p})
	set {_cost1} to {_1}^2
	set {_cost11} to format({_cost1})
	set {_cost2} to ({_2} * 10000)^2
	set {_cost22} to format({_cost2})
	format gui slot 1 of {_p} with bell named "&eMedals: &8[&e+%{_1}%&8]" with lore "&7 > Click to Upgrade:" and "&eCost: &f%{_cost11}% &eMedals" to run function medalUpgrade({_p}, {_cost1})
	format gui slot 3 of {_p} with emerald named "&b%{_2}%%% &7Bonus" with lore "&7 > Click to Upgrade:" and "&eCost: &f%{_cost22}% &eGold" to run function bonusUpgrade({_p}, {_cost2})
	if tool of {_p} is bow:
		format gui slot 5 of {_p} with enchanted book named "&cEnchanting &7Menu" with lore "&7 > Gather up enchantments using &egold" to run function bowenchants({_p})
	else if tool of {_p} is crossbow:
		format gui slot 5 of {_p} with enchanted book named "&cEnchanting &7Menu" with lore "&7 > Gather up enchantments using &egold" to run function crossbownchants({_p})
	else if tool of {_p} is trident:
		format gui slot 5 of {_p} with enchanted book named "&cEnchanting &7Menu" with lore "&7 > Gather up enchantments using &egold" to run function tridentenchants({_p})
	else:
		format gui slot 5 of {_p} with enchanted book named "&cEnchanting &7Menu" with lore "&7 > Gather up enchantments using &egold" to run function enchants({_p})
	set {_block} to {p_block::%{_p}%}
	set {_blockk} to format({p_block::%{_p}%})
	set {_bonus} to format((({p_bonus::%{_p}%} / 100) - 1) * {_block})
	set {_blessing} to format((({blessing} / 100) - 1) * {_block})
	format gui slot 7 of {_p} with nether star named "&bRebirth" with lore "&7 > Click to &bRebirth &7and Gain Medals" and "&7 > %{_blockk}% &b+%{_bonus}% (%{p_bonus::%{_p}%}%%%) &e+%{_blessing}% (%{blessing}%%%) &7Medals" to run function rebirth({_p})

function isGlass(p: player, s: integer) :: boolean:
	if slot {_s} of {_p} is light gray stained glass or lime stained glass or light blue stained glass or orange stained glass or black stained glass:
		return true
	return false

function armor(p: player):
	open virtual chest inventory with size 4 named "&e&lARMOR &8Upgrades" to {_p}
	if helmet of {_p} is light gray stained glass or lime stained glass or light blue stained glass or orange stained glass or black stained glass:
		format gui slot 0 of {_p} with helmet of {_p}
		set {_helmet} to helmet of {_p}
	else if isGlass({_p}, 12) is true:
		format gui slot 0 of {_p} with slot 12 of {_p}
		set {_helmet} to slot 12 of {_p}
	else if isGlass({_p}, 21) is true:
		format gui slot 0 of {_p} with slot 21 of {_p}
		set {_helmet} to slot 21 of {_p}
	else if isGlass({_p}, 22) is true:
		format gui slot 0 of {_p} with slot 22 of {_p}
		set {_helmet} to slot 22 of {_p}
	else if isGlass({_p}, 23) is true:
		format gui slot 0 of {_p} with slot 23 of {_p}
		set {_helmet} to slot 23 of {_p}
	else if isGlass({_p}, 30) is true:
		format gui slot 0 of {_p} with slot 30 of {_p}
		set {_helmet} to slot 30 of {_p}
	else if isGlass({_p}, 31) is true:
		format gui slot 0 of {_p} with slot 31 of {_p}
		set {_helmet} to slot 31 of {_p}
	else if isGlass({_p}, 32) is true:
		format gui slot 0 of {_p} with slot 32 of {_p}
		set {_helmet} to slot 32 of {_p}
	if chestplate of {_p} is chestplate:
		format gui slot 9 of {_p} with chestplate of {_p}
		set {_chestplate} to chestplate of {_p}
	else:
		format gui slot 9 of {_p} with slot 13 of {_p}
		set {_chestplate} to slot 13 of {_p}
	format gui slot 18 of {_p} with leggings of {_p}
	set {_leggings} to leggings of {_p}
	if boots of {_p} is not {hermes}:
		format gui slot 27 of {_p} with boots of {_p}
		set {_boots} to boots of {_p}
	else:
		format gui slot 27 of {_p} with slot 14 of {_p}
		set {_boots} to slot 14 of {_p}

on right click:
	if player's tool is pickaxe or axe or shovel or sword:
		if player's tool is wooden axe:
			stop
		cancel event
		tool(player)
	if player's tool is bow or crossbow or trident:
		player is sneaking
		cancel event
		set slot 25 of player to 64 of arrow named "&e&lARROW &7Shop" with lore "&7> Click to Open"
		tool(player)
	if name of player's tool is "&e&lSTATISTICS":
		cancel event
		stats(player)
	if name of player's tool is "&e&lARMOR":
		cancel event
		armor(player)
	if name of player's tool is "&e&lSETTINGS":
		cancel event
		settings(player)

# ======== STAFF COMMANDS ======== STAFF COMMANDS ========
# ======== STAFF COMMANDS ======== STAFF COMMANDS ========
# ======== STAFF COMMANDS ======== STAFF COMMANDS ========

command /staffchat [<text>]:
	aliases: /sc
	permission: staff
	permission message: {@staff} {@permission}
	trigger:
		if arg-1 is not set:
			if {staffchat::%player%} is not set:
				set {staffchat::%player%} to true
				send "{@staff} &7Toggle &aENABLED"
			else:
				delete {staffchat::%player%}
				send "{@staff} &7Toggle &cDISABLED"
		else:
			loop all players:
				if loop-player has permission "sc.staffchat":
					send formatted "{@staff} %player's prefix%&r%player's display name%&7: &r%arg 1%" to loop-player
on chat:
	if {staffchat::%player%} is set:
		cancel event
		loop all players:
			if loop-player has permission "sc.staffchat":
				send formatted "{@staff} %player's prefix%&r%player's display name%&7: &r%message%" to loop-player
every 1 second in "{@world}":
	loop all players:
		if {staffchat::%loop-player%} is true:
			send action bar "{@staff} &aEnabled" to loop-player
on chat:
	if player is op:
		stop
	else:
		if {SkCheat::spam.m::%uuid of player%} is message:
			add 1 to {SkCheat::spam.p::%uuid of player%}
			if {SkCheat.spam.notify::%uuid of player%} is not set:
				set {SkCheat.spam.notify::%uuid of player%} to now
			if difference between {SkCheat.spam.notify::%uuid of player%} and now is more than 1 second:
				if {SkCheat::spam.p::%uuid of player%} is greater than 6:
					kick the player due to "{@shaft} You were spamming."
					clear {SkCheat::spam.p::%uuid of player%}
		else:
			set {SkCheat::spam.m::%uuid of player%} to message	
on join:
	clear {SkCheat::spam.p::%uuid of player%}
	clear {SkCheat::spam.m::%uuid of player%}
on disconnect:
	clear {SkCheat::spam.p::%uuid of player%}
	clear {SkCheat::spam.m::%uuid of player%}
command /mutechat:
	permission: staff
	permission message: {@staff} {@permission}
	trigger:
		if {Globalchat} is not set:
			set {Globalchat} to true
			broadcast "{@shaft} &7Chat &cMUTED &7by %player%"
			stop trigger
		if {Globalchat} is set:
			clear {Globalchat}
			broadcast "{@shaft} &7Chat &aUNMUTED &7by %player%"
on chat:
	if {Globalchat} is true:
		if player has permission "chat.mute.bypass":
			stop trigger
		else:
			cancel event
			send "{@shaft} &cChat is currently muted."
command /clearchat:
	permission: staff
	permission message: {@staff} {@permission}
	aliases: /cc
	trigger:
		loop 100 times:
			broadcast ""
		send "{@shaft} &aYou have cleared the chat"
command /clearlag:
	permission: staff
	permission message: {@staff} {@permission}
	trigger:
		set {_n} to size of all entities in "world"
		delete all entities in "world"
		broadcast "{@shaft} &7Cleared &c%{_n}% &7entities"

# ======== ADMIN ======== ADMIN ========
# ======== ADMIN ======== ADMIN ========
# ======== ADMIN ======== ADMIN ========

command /modify [<offline player>] [<text>] [<text>] [<integer>]:
	trigger:
		if player is op:
			if arg-1 is not set:
				send "{@admin} &f/modify &f<player>"
				stop
			else if arg-2 is not "level" or "gold" or "totalgold" or "gem" or "medal" or "totalmedal" or "token" or "block" or "totalblock" or "mkill" or "mdeath" or "pkill" or "pdeath" or "rebirth" or "all":
				send "{@admin} &f/modify <%arg-1%> &f<level gold totalgold gem medal totalmedal token block totalblock mkill mdeath pkill pdeath rebirth all>"
				stop
			else if arg-3 is not "add" or "remove" or "set" or "reset":
				if arg-2 is "reset":
					send "{@admin} &f/modify <%arg-1%> <%arg-2%> &f<reset>"
				else:
					send "{@admin} &f/modify <%arg-1%> <%arg-2%> &f<add remove set reset>"
				stop
			else if arg-4 is not set:
				if arg-3 is not "reset":
					send "{@admin} &f/modify <%arg-1%> <%arg-2%> <%arg-3%> &f<integer>"
					stop
			if arg-3 is "add":
				add arg-4 to {p_%arg-2%::%arg-1%}
				set {_nn} to format(arg-4)
				send "{@admin} &7Added &e%{_nn}% &7to &e%arg-1%&e's &7%arg-2%"
			else if arg-3 is "remove":
				if arg-2 is "level":
					if arg-4 is greater than {p_level::%arg-1%} - 1:
						set {_n} to {p_level::%arg-1%} - 1
				else if arg-4 is greater than {p_%arg-2%::%arg-1%}:
					set {_n} to {p_%arg-2%::%arg-1%}
				else:
					set {_n} to arg-4
				remove {_n} from {p_%arg-2%::%arg-1%}
				set {_nn} to format({_n})
				send "{@admin} &7Removed &e%{_nn}% &7from &e%arg-1%&e's &7%arg-2%"
			else if arg-3 is "set":
				if arg-2 is "level":
					if arg-4 is less than 1:
						set {_n} to 1
					else:
						set {_n} to arg-4
				else if arg-4 is less than 0:
					set {_n} to 0
				else:
					set {_n} to arg-4
				set {p_%arg-2%::%arg-1%} to {_n}
				set {_nn} to format({_n})
				send "{@admin} &7Set &e%arg-1%&e's &7%arg-2% &7to &e%{_nn}%"
			else if arg-3 is "reset":
				if arg-2 is "level":
					set {_n} to 1
				else if arg-2 is "all":
					set {p_level::%arg-1%} to 1
					set {p_gold::%arg-1%} to 0
					set {p_totalgold::%arg-1%} to 0
					set {p_gem::%arg-1%} to 0
					set {p_medal::%arg-1%} to 0
					set {p_totalmedal::%arg-1%} to 0
					set {p_token::%arg-1%} to 0
					set {p_block::%arg-1%} to 0
					set {p_totalblock::%arg-1%} to 0
					set {p_mkill::%arg-1%} to 0
					set {p_mdeath::%arg-1%} to 0
					set {p_pkill::%arg-1%} to 0
					set {p_pdeath::%arg-1%} to 0
					set {p_rebirth::%arg-1%} to 0
					send "{@admin} &7Reset all for &e%arg-1%"
					stop
				else:
					set {_n} to 0
				set {p_%arg-2%::%arg-1%} to {_n}
				send "{@admin} &7Reset &e%arg-1%&e's &7%arg-2%"
		else:
			send "{@admin} {@permission}"